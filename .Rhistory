}
#Extract time to TVD measurement
temp <- data[["tvd_time_report"]]
if(!is_empty(temp)){
# colnames(temp) <- paste0("t",1:ncol(temp))
temp <- as.data.frame(temp)
temp$sim <- 1:tot_sim
temp$alg <- algorithm
temp <- temp |> select(alg,sim,everything())
temp <- temp |> pivot_longer(cols=starts_with("V"),names_to="measurement",values_to="time")
temp2 <- data[["tvd_report"]]
temp2 <- as.data.frame(temp2)
temp2$sim <- 1:tot_sim
temp2$alg <- algorithm
temp2 <- temp2 |> select(alg,sim,everything())
temp2 <- temp2 |> pivot_longer(cols=starts_with("V"),names_to="measurement",values_to="tvd")
temp <- left_join(temp,temp2,by=c("alg","sim","measurement"))
temp$measurement <- as.numeric(gsub("V","",temp$measurement))
tvd_report <- rbind(tvd_report,temp)
}
}
if(chosen_dim=="highdim"){
### Specific extractions for highdim example
if(data_sum|> slice(i) |> pull(model)=="bimodal"){
p <- data_sum$p;
}
if(data_sum|> slice(i) |> pull(model)=="gset"){
file_matrix <- paste0("gset/",data_sum |> slice(i)|> pull(file),".txt")
p <- readParameters(file_matrix)
}
##### Extract distance to modes
if(check_number_sim==1){
for (s in 1:tot_sim){
for(t in 1:length(temperatures)){
# Distance mode has rows=iterations, columns=replicas, slices=simulations
temp_tibble1 <- tibble(dist=data[["distance_mode1"]][,t,s],
alg=algorithm,
sim=s,
temperature=temperatures[t],
iteration=1:length(dist),
mode="m1")
temp_tibble2 <- tibble(dist=data[["distance_mode2"]][,t,s],
alg=algorithm,
sim=s,
temperature=temperatures[t],
iteration=1:length(dist),
mode="m2")
temp_tibble0 <- tibble(dist=data[["distance_origin"]][,t,s],
alg=algorithm,
sim=s,
temperature=temperatures[t],
iteration=1:length(dist),
mode="m0")
distances <- rbind(distances,temp_tibble1,temp_tibble2,temp_tibble0)
rm(list=c("temp","temp_tibble1","temp_tibble2","temp_tibble0"))
}
}
}else{
for(mm in 1:2){###for(mm in 0:2) for report considering distance to 0
output_name <- paste0("distance_mode",mm)
chosen_mode <- paste0("m",mm)
if(mm==0){output_name <- "distance_origin"}
### Extract minimum distances
temp_m <- as.data.frame(t(apply(data[[output_name]],c(2,3),min)))
colnames(temp_m) <- temperatures
temp_m$alg <- algorithm
temp_m$mode <- chosen_mode
temp_m$sim <- (1:tot_sim)
temp_m <- temp_m |> pivot_longer(-(alg:sim),names_to="temperature",values_to = "min_dist")
# head(temp_m)
### Extract maximum distances
temp_M <- as.data.frame(t(apply(data[[output_name]],c(2,3),max)))
colnames(temp_M) <- temperatures
temp_M$alg <- algorithm
temp_M$mode <- chosen_mode
temp_M$sim <- (1:tot_sim)
temp_M <- temp_M |> pivot_longer(-(alg:sim),names_to="temperature",values_to = "max_dist")
# head(temp_M)
temp_join <- left_join(temp_m,temp_M,by=c("alg","sim","mode","temperature"))
#### Extract iterations to find those distances
num_temp <- length(temperatures)
iters <- as.data.frame(matrix(,ncol=num_temp+2,nrow=tot_sim*2))
for(s in 1:tot_sim){
index_min <- 2*s - 1 #on odd entries
index_max <- 2*s #On even entries
iters[index_min:index_max,1] <- s#Identify simulation
iters[index_min,2] <- "min_iter"#Identify simulation
iters[index_max,2] <- "max_iter"#Identify simulation
iters[index_min,-(1:2)] <- apply(data[[output_name]][,,s],2,which.min)
iters[index_max,-(1:2)] <- apply(data[[output_name]][,,s],2,which.max)
}
colnames(iters) <- c("sim","measure",temperatures)
iters$alg <- algorithm
iters$mode <- chosen_mode
iters <- iters |>
select(alg,measure,mode,sim,everything()) |>
pivot_longer(-(alg:sim),names_to="temperature",values_to = "iter")
iters <- iters |>
pivot_wider(id_cols = c(alg,sim,temperature,mode),names_from = measure,values_from = iter)
temp_join <- left_join(temp_join,iters,by=c("alg","sim","temperature","mode")) |>
select(alg,sim, temperature,mode,min_dist,max_dist,min_iter,max_iter)
distances <- rbind(distances,temp_join)
}
}
#Find the row index of the first minimum value for each column (temperature)
}
if(!is_empty(data[["round_trips"]]) && ncol(data[["round_trips"]])>1){
#Extract number of round trips rate
temp <- as.data.frame(data[["round_trips"]])
colnames(temp) <- 1:ncol(temp)
temp$sim <- 1:tot_sim
temp$alg <- algorithm
temp <- temp |> select(alg,sim,everything())
round_trip <- rbind(round_trip,temp)
# Extract replica swap rate
temp <- as.data.frame(data[["swap_rate"]])
colnames(temp) <- 1:ncol(temp)
temp$sim <- 1:tot_sim
temp$alg <- algorithm
temp <- temp |> select(alg,sim,everything())
swap_rate <- rbind(swap_rate,temp)
}
if(!is_empty(data[["total_iter"]])&& ncol(data[["total_iter"]])>1){
# Extract total iterations
dims<- dim(data[["total_iter"]])
full_iter[[k]] <- data[["total_iter"]]
full_iter_names[k] <- algorithm
k <- k+1;
temp <- as.data.frame(t(colSums(data[["total_iter"]])))/dims[1]
#temp is the average number of Rejection Free steps before trying a swap
colnames(temp) <- 1:ncol(temp)
temp$sim <- 1:tot_sim
temp$alg <- algorithm
temp <- temp |> select(alg,sim,everything())
iterations <- rbind(iterations,temp)
}
}
##### Delete first row with NA#####
# round_trip <- round_trip |> filter(!is.na(alg))
# if(exists("swap_rate")){swap_rate <- swap_rate |> filter(!is.na(alg))}
# iterations <- iterations |> filter(!is.na(alg))
# time_taken <- time_taken |> filter(!is.na(alg))
##### Export plots and tables #####
export_path <- paste0("C:/Users/ralex/Documents/src/paper_iit_pt/images/",chosen_dim,"_ex")
export_file_name <- paste0(paste0(chosen_ids,collapse="_"),"_",chosen_dim)
if(print_bimodal){export_file_name <- "bimodal"}
if(print_multimodal){export_file_name <- "multimodal"}
# full_path <- file.path(export_path,paste0("tvd_",export_file_name,".jpg"))
#################################### REPORTS FOR LOW AND HIGH DIMENSION ######
##### Time taken #####
# time_plot <- time_taken|>  filter(alg!='IIT') |>
#   ggplot(aes(x=alg,y=time,fill=alg)) +
#   geom_boxplot(show.legend = FALSE)+
#   labs(fill='Algortihm',x="",y="Time in seconds")+
#   theme_minimal(base_size = 17)+
#   theme(legend.key.size = unit(1, 'cm'))
# time_plot
time_table <- time_taken |> filter(!str_starts(alg,'IIT')) |>
group_by(alg) |>
summarise(min=min(time),
q1=quantile(time,probs=0.25),
median=quantile(time,probs=0.5),
mean=mean(time),
q3=quantile(time,probs=0.75),
max=max(time))
jpeg(file.path(export_path,paste0(export_file_name,"_time_table",".jpg")),width=80*ncol(time_table),height=35*nrow(time_table),pointsize = 30)
grid.arrange(tableGrob(time_table))
dev.off()
(time_boxplot <- time_taken |>
filter(!str_starts(alg,'IIT')) |>
ggplot(aes(x=alg,y=time))+
geom_boxplot())
##### Report on average swap rate
#First create column names depending on the number of replicas
if(num_replicas>1){
swap_names <- c()
for(i in 1:(num_replicas-1)){
swap_names <- c(swap_names,paste0(i,"â†”",i+1))
}
swap_report <- swap_rate |>
group_by(alg) |>
summarize(across(-sim, function(x) mean(x, na.rm = TRUE)))
colnames(swap_report) <- c("alg",swap_names)
jpeg(file.path(export_path,paste0(export_file_name,"_table_swap_rate",".jpg")),width=93*ncol(swap_report),height=33*nrow(swap_report),pointsize = 30)
grid.arrange(tableGrob(swap_report))
dev.off()
##### Report on average round trip rate
rt_report <- round_trip |>
group_by(alg) |>
summarize(across(-sim, function(x) mean(x, na.rm = TRUE)))
colnames(rt_report) <- c("alg",paste0("R",1:num_replicas))
jpeg(file.path(export_path,paste0(export_file_name,"_table_roundtrip_rate",".jpg")),width=90*ncol(rt_report),height=40*nrow(rt_report),pointsize = 30)
grid.arrange(tableGrob(rt_report))
dev.off()
}
if(chosen_dim=="lowdim"){
##### Delete first row with NA#####
tvd <-  tvd |> filter(!is.na(alg))
mode_visit <- mode_visit |> filter(!is.na(alg))
pi_modes <- pi_modes|> filter(!is.na(alg))
mode_time <- mode_time |> filter(!is.na(alg))
##### Compare estimation of modes #####
pi_modes |> pivot_longer(cols = -(alg:sim), names_to = "mode", values_to = "pi_est") |>
ggplot(aes(x=mode,y=pi_est,fill=alg))+
geom_boxplot(show.legend = FALSE)+
geom_hline(yintercept = pi.true[modes[1]+1], color = "red", linetype = "dashed", size = 1)+
facet_wrap(~alg)
# +
#   theme_minimal(base_size = 17)+
#   theme(legend.key.size = unit(1, 'cm'))
#
#### TVD computed only with the modes
col_selected <- colnames(pi_modes)
col_selected <- col_selected[col_selected!="alg" & col_selected!="sim"]
pi_modes |> rowwise() |>
mutate(tvd=0.5*sum(abs(pi.true[modes+1]-c_across(col_selected)))) |>
ungroup() |>
select(alg,tvd) |>
ggplot(aes(x=alg,y=tvd,fill=alg)) +
geom_boxplot(show.legend = FALSE)+
labs(fill='Algortihm',x="",y="Total Variation Distance")
# +
#   theme_minimal(base_size = 17)+
#   theme(legend.key.size = unit(1, 'cm'))
#Min and max values in TVD
min_tvd_1 <-  pi_modes |> rowwise() |>
mutate(tvd=0.5*sum(abs(pi.true[modes+1]-c_across(col_selected)))) |>
select(alg,tvd) |>
group_by(alg) |> slice(which.min(tvd))
max_tvd_1 <-  pi_modes |> rowwise() |>
mutate(tvd=0.5*sum(abs(pi.true[modes+1]-c_across(col_selected)))) |>
select(alg,tvd) |>
group_by(alg) |> slice(which.max(tvd))
min_tvd_2 <- tvd |> select(alg,tvd) |> group_by(alg) |> slice(which.min(tvd))
max_tvd_2 <- tvd |> select(alg,tvd) |> group_by(alg) |> slice(which.max(tvd))
min_tvd_compare <- left_join(min_tvd_1,min_tvd_2,by=c("alg"),suffix = c("_modes","_full"))
max_tvd_compare <- left_join(max_tvd_1,max_tvd_2,by=c("alg"),suffix = c("_modes","_full"))
grid.arrange(tableGrob(min_tvd_compare))
grid.arrange(tableGrob(max_tvd_compare))
##### Total Variation Distance #####
tvd_plot <- tvd |>  filter(!str_starts(alg,'IIT')) |>
ggplot(aes(x=alg,y=tvd,fill=alg)) +
geom_boxplot()+
labs(fill='Algortihm',x="",y="Total Variation Distance")
# +
#     theme_minimal(base_size = 17)+
#     theme(legend.key.size = unit(1, 'cm'))
tvd_plot
jpeg(file.path(export_path,paste0(export_file_name,"_tvd",".jpg")),width=800,height =400,pointsize = 30)
print(tvd_plot)
dev.off()
##### First visit to modes #####
col_names <- col_selected
mode_sum <- mode_visit |>
rowwise()|>
mutate(last_visit=max(c_across(all_of(col_names))), first_visit=min(c_across(all_of(col_names))[c_across(all_of(col_names))>0])) |>
mutate(first_mode =  names(pick(all_of(col_names)))[which(c_across(all_of(col_names)) == first_visit)[1]]) |>
mutate(last_mode =  names(pick(all_of(col_names)))[which(c_across(all_of(col_names)) == last_visit)[1]]) |>
mutate(total_modes = sum(c_across(all_of(col_names)) > 0)) |>
select(-all_of(col_names))
##### Report on number of modes visited by each algorithm
table_visited <- mode_sum |> rename(algorithm=alg) |>
group_by(algorithm,total_modes) |>
summarise(count=n()) |> ungroup() |> arrange(total_modes,desc(algorithm)) |>
pivot_wider(id_cols =algorithm,
names_from = total_modes,
values_from = count,
values_fill=0)
jpeg(file.path(export_path,paste0(export_file_name,"_table_visited_modes",".jpg")),width=100 + (60*(ncol(table_visited)-1)),height=40*nrow(table_visited),pointsize = 30)
grid.arrange(tableGrob(table_visited))
dev.off()
##### Report on number of iterations for the original replica to visit all modes (most of the times after a swap)
iterations_to_explore <- mode_sum |> filter(!str_starts(alg,'IIT')) |>
group_by(alg) |>
summarise(min=min(last_visit),
q1=quantile(last_visit,probs=0.25),
median=quantile(last_visit,probs=0.5),
mean=mean(last_visit),
q3=quantile(last_visit,probs=0.75),
max=max(last_visit))
jpeg(file.path(export_path,paste0(export_file_name,"_table_iterations",".jpg")),width=60*ncol(iterations_to_explore),height=35*nrow(iterations_to_explore),pointsize = 30)
grid.arrange(tableGrob(iterations_to_explore))
dev.off()
##### Report on number of replica swaps needed to visit all modes
# First algorithms do 2k iterations before trying a replica swap
swaps_to_explore <- mode_sum |> filter(!str_starts(alg,'IIT'),!str_starts(alg,'PT A-IIT m')) |>
mutate(last_visit=last_visit/interswap) |>
group_by(alg) |>
summarise(min=min(last_visit),
q1=quantile(last_visit,probs=0.25),
median=quantile(last_visit,probs=0.5),
mean=mean(last_visit),
q3=quantile(last_visit,probs=0.75),
max=max(last_visit))
if(nrow(iterations)>0){
temp <- mode_sum |> filter(str_starts(alg,'PT A-IIT m')) |>
select(alg,sim,last_visit) |>
left_join(iterations,by=c("alg","sim")) |>
mutate(last_visit=last_visit/`1`) |>
select(alg,last_visit) |>
group_by(alg) |>
summarise(min=round(min(last_visit),2),
q1=round(quantile(last_visit,probs=0.25),2),
median=round(quantile(last_visit,probs=0.5),2),
mean=round(mean(last_visit),2),
q3=round(quantile(last_visit,probs=0.75),2),
max=round(max(last_visit),2))
swaps_to_explore <- rbind(swaps_to_explore,temp)
## Report on number of iterations interswap
interswap_report <- data_sum |> select(id,interswap)
rep_iter <- iterations |>
mutate(id=as.numeric(str_extract(alg,"\\d+"))) |>
left_join(interswap_report,by="id") |>
select(-id) |>
group_by(alg,interswap) |>
summarise(across(-sim, mean))
if(print_bimodal || print_multimodal){rep_iter <- rep_iter |> select(-interswap)}
jpeg(file.path(export_path,paste0(export_file_name,"_interswaps",".jpg")),width=85*ncol(rep_iter),height=35*nrow(rep_iter),pointsize = 30)
grid.arrange(tableGrob(rep_iter))
dev.off()
}
jpeg(file.path(export_path,paste0(export_file_name,"_table_swaps",".jpg")),width=100*ncol(swaps_to_explore),height=35*nrow(swaps_to_explore),pointsize = 30)
grid.arrange(tableGrob(swaps_to_explore))
dev.off()
#### Report on time to visit the modes
(plot_time_mode <- mode_time |> group_by(alg,sim) |>
summarise(first_time=min(time),last_time=max(time)) |>
ggplot(aes(x=alg,y=last_time, fill=alg)) +
geom_boxplot()+
labs(fill='Algortihm',y="seconds",x="",title="Time to find last mode")+
theme(axis.text.x = element_blank()))
# theme_minimal(base_size = 17)+
# theme(legend.key.size = unit(1, 'cm'),
#       axis.text.x = element_blank()))
mode_time |> group_by(alg,sim) |>
summarise(first_time=min(time),last_time=max(time)) |> ungroup() |>
ggplot(aes(x=first_time,y=last_time, col=alg)) +
geom_point()
forsurv <- mode_time |>group_by(alg,sim) |>
summarise(first_time=min(time),last_time=max(time)) |> ungroup() |>
select(alg,last_time)
# forsurv <- forsurv |> filter(str_detect(alg,"\\(26[7]\\)|\\(27[1268]\\)|\\(28[023]\\)"))
fit <- survfit(Surv(last_time,rep(1,nrow(forsurv)))~alg,data=forsurv)
if(check_number_modes=="bimodal"){time_br <- 0.2}
if(check_number_modes=="7_mode"){time_br <- 0.5}
(plot_surv_mode <- ggsurvplot(fit,
data=forsurv,
fun="event",
palette = "Set1",    # Color palette
xlab = "Time (seconds)",
ylab = "Prop. of simulations visiting all modes",
legend.title = "Algorithm",
# break.time.by = time_br,
font.x = 15,        # X-axis label font size
font.y = 15,        # Y-axis label font size
font.tickslab = 12, # Axis tick labels (numbers) font size
font.legend = 10))   # Legend text font size)
table_time_mode <- mode_time |> group_by(alg,sim) |>
summarise(first_time=min(time),last_time=max(time)) |>
ungroup() |> group_by(alg) |>
summarise(min=min(last_time),
q1=quantile(last_time,probs=0.25),
median=quantile(last_time,probs=0.5),
mean=mean(last_time),
q3=quantile(last_time,probs=0.75),
max=max(last_time))
grid.arrange(tableGrob(table_time_mode))
jpeg(file.path(export_path,paste0(export_file_name,"_time_mode",".jpg")),width=800,height =400,pointsize = 30, quality=100)
print(plot_surv_mode)
dev.off()
### TVD report
sum_tvd <- tvd_report |> mutate(measurement=measurement/max(measurement)) |>
group_by(alg,measurement) |>
summarise(mean_time=mean(time),
min_time=min(time),
q1_time=quantile(time,0.25),
q2_time=quantile(time,0.5),
q3_time=quantile(time,0.75),
max_time=max(time),
mean_tvd=mean(tvd),
min_tvd=min(tvd),
q1_tvd=quantile(tvd,0.25),
q2_tvd=quantile(tvd,0.5),
q3_tvd=quantile(tvd,0.75),
max_tvd=max(tvd))
max_tvd_plot <- sum_tvd |>
ggplot(aes(x=max_time,y=max_tvd, col=alg))+
geom_point()+
geom_line()+
scale_x_continuous()+
labs(title='Maximum TVD',color='Algorithm', x="Seconds", y="Total Variation Distance")
max_tvd_plot
mean_tvd_plot <- sum_tvd |>
ggplot(aes(x=max_time,y=mean_tvd, col=alg))+
geom_point()+
geom_line()+
scale_x_continuous()+
labs(title='Mean TVD',color='Algorithm', x="Seconds", y="Total Variation Distance")
mean_tvd_plot
trunc_mean_tvd_plot <- sum_tvd |> filter(mean_tvd<0.1) |>
ggplot(aes(x=max_time,y=mean_tvd, col=alg))+
geom_point(size=2.5)+
geom_line(linewidth=0.8)+
scale_x_continuous()+
labs(title='Mean TVD',color='Algorithm', x="Seconds", y="Total Variation Distance")+
theme_minimal()
trunc_mean_tvd_plot
sum_tvd |>
ggplot(aes(x=max_time,y=q2_tvd, fill=alg, col=alg))+
geom_line(linewidth=0.8)+
geom_point(pch=1,size=1.5)+
geom_ribbon(aes(ymin=q1_tvd, ymax=q3_tvd),alpha=0.04)
sum_tvd |>
ggplot(aes(x=max_time,y=q2_tvd, col=alg))+
geom_point()+
geom_line()+
scale_x_continuous()+
labs(title='Median TVD',color='Algorithm', x="Seconds", y="Total Variation Distance")
sum_tvd |>
ggplot(aes(x=max_time,y=min_tvd, col=alg))+
geom_point()+
geom_line()+
scale_x_continuous()+
labs(title='Minimum TVD',color='Algorithm', x="Seconds", y="Total Variation Distance")
jpeg(file.path(export_path,paste0(export_file_name,"_tvd_mean",".jpg")),width=800,height =400,pointsize = 30)
print(mean_tvd_plot)
dev.off()
jpeg(file.path(export_path,paste0(export_file_name,"_tvd_mean_trunc",".jpg")),width=800,height =400,pointsize = 30)
print(trunc_mean_tvd_plot)
dev.off()
jpeg(file.path(export_path,paste0(export_file_name,"_tvd_max",".jpg")),width=800,height =400,pointsize = 30)
print(max_tvd_plot)
dev.off()
}# Finish low dim reports
#Starts high dim reports
if(chosen_dim=="highdim"){
##### Delete first row with NA#####
# max_lik <- max_lik|> filter(!is.na(alg))
# loglik_visited <- loglik_visited |> filter(!is.na(alg))
# iter_visit <- iter_visit|> filter(!is.na(alg))
if(check_number_sim==1){
### This reports only works when there's only 1 simulation
{
### Report on how far each replica was of each mode
distance_report <- distances |> group_by(alg, temperature, mode) |>
summarise(closer=min(dist),
farther=max(dist),
average=mean(dist),
d1=quantile(dist,0.1),
d2=quantile(dist,0.2),
q1=quantile(dist,.25),
d3=quantile(dist,0.3),
d4=quantile(dist,0.4),
q2=quantile(dist,0.5),
d6=quantile(dist,0.6),
d7=quantile(dist,0.7),
q3=quantile(dist,0.75),
d8=quantile(dist,0.8),
d9=quantile(dist,0.9))
if(unique(p)==800){dist_to_modes <- 785}else{dist_to_modes <- unique(p)}
distance_report <- distance_report|> ungroup() |> add_row(alg=paste0("p=",unique(p)),
temperature=NA,
mode="M2M",
closer=dist_to_modes,
farther=dist_to_modes,
average=dist_to_modes,
d1=0,d2=0,q1=0,
d3=0,d4=0,q2=0,
d6=0,d7=0,q3=0,
d8=0,d9=0)
jpeg(file.path(export_path,paste0(export_file_name,"_distance_modes",".jpg")),width=44*ncol(distance_report),height=25*nrow(distance_report),pointsize = 30)
grid.arrange(tableGrob(distance_report))
dev.off()
### Report on how quickly they reached the closer and farther distance to modes
speed_to_mode <- distances |>
group_by(alg,sim,temperature,mode) |>
summarise(min_dist=min(dist),
iteration_at_min_distance = iteration[which.min(dist)][1], # takes first if ties
max_dist=max(dist),
iteration_at_max_distance = iteration[which.max(dist)][1])
jpeg(file.path(export_path,paste0(export_file_name,"_speed_to_modes",".jpg")),width=100*ncol(speed_to_mode),height=25*nrow(speed_to_mode),pointsize = 30)
grid.arrange(tableGrob(speed_to_mode))
dev.off()
}
}else{
distance_report <- distances |>
group_by(alg,temperature,mode) |>
summarise(min_d=min(min_dist),
min_average=mean(min_dist),
fastest_min=min(min_iter),
mean_min=mean(min_iter),
slowest_min=max(min_iter))
# ### Report for each algorithm
#    for(id in chosen_ids){
#      id_text <- as.character(id)
#      cat(paste0("printing report for id:",id_text,"\n"))
#      temp_report <- distance_report |> filter(str_detect(alg,id_text))
#      jpeg(file.path(export_path,paste0(id_text,"_",chosen_dim,"_distance_report",".jpg")),width=80*ncol(temp_report),height=23*nrow(temp_report),pointsize = 30)
#      grid.arrange(tableGrob(temp_report))
#      dev.off()
#    }
### Report of temperature 1
temp_1_report <- distance_report |> filter(temperature==1)
jpeg(file.path(export_path,paste0(export_file_name,"_dist_to_modes_t1",".jpg")),width=90*ncol(temp_1_report),height=25*nrow(temp_1_report),pointsize = 30)
grid.arrange(tableGrob(temp_1_report))
dev.off()
temp_max_report <- distance_report |> filter(temperature==max(temperatures))
jpeg(file.path(export_path,paste0(export_file_name,"_dist_to_modes_tmax",".jpg")),width=90*ncol(temp_1_report),height=25*nrow(temp_1_report),pointsize = 30)
grid.arrange(tableGrob(temp_max_report))
dev.off()
}
}
